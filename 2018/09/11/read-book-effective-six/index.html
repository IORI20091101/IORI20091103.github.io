<!DOCTYPE html><html lang="zh-CN"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-tag-common@latest/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="多弗朗明哥"><meta name="copyright" content="多弗朗明哥"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>Effective JavaScript (六) | 唐吉诃德的小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" href="https://cdn.darknights.cn/assets/images/favicon.ico"><link rel="mask-icon" href="https://cdn.darknights.cn/assets/images/favicon.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"sdongzhi.com","root":"/","title":"唐吉诃德的小站","version":"1.6.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"algolia":{"appID":"ZH3RNMJ8TX","apiKey":"d3c4e9cb3d4b25b901414d257a20d970","indexName":"Pages","hits":{"per_page":8}},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="唐吉诃德的小站" type="application/atom+xml"><link rel="stylesheet" href="/styles/custom.css"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=UA-107257239-1"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107257239-1');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="函数调用理解函数调用， 方法调用，构造函数调用之间的不同。 12345678910111213141516171819202122232425262728293031323334最简单的函数调用function hello(username) &amp;#123;	return &quot;hello, &quot; + username;&amp;#125;hello(&quot;Keyser soze&amp;quo">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective JavaScript (六)">
<meta property="og:url" content="https://sdongzhi.com/2018/09/11/read-book-effective-six/index.html">
<meta property="og:site_name" content="唐吉诃德的小站">
<meta property="og:description" content="函数调用理解函数调用， 方法调用，构造函数调用之间的不同。 12345678910111213141516171819202122232425262728293031323334最简单的函数调用function hello(username) &amp;#123;	return &quot;hello, &quot; + username;&amp;#125;hello(&quot;Keyser soze&amp;quo">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-09-11T00:00:00.000Z">
<meta property="article:modified_time" content="2021-09-27T06:34:37.005Z">
<meta property="article:author" content="多弗朗明哥">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="读书总结">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="多弗朗明哥"><img width="96" loading="lazy" src="/images/avatar.jpeg" alt="多弗朗明哥"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">多弗朗明哥</a></div><a class="site-name" href="/about/site.html">唐吉诃德的小站</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">54</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">36</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/IORI20091101" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/iori20091101" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/donduffy" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:sdzzlyjy@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">熟练掌握高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8call%E6%96%B9%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A5%E6%94%B6%E8%80%85%E6%9D%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">使用call方法自定义接收者来调用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8apply%E6%96%B9%E6%B3%95%E9%80%9A%E8%BF%87%E4%B8%8D%E5%90%8C%E6%95%B0%E9%87%8F%E7%9A%84%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">使用apply方法通过不同数量的参数调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8arguments%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">使用arguments创建可变参数的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E4%BF%AE%E6%94%B9arguments%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">永远不要修改arguments对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E4%BF%9D%E5%AD%98arguments%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">使用变量保存arguments的引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8bind%E6%96%B9%E6%B3%95%E6%8F%90%E5%8F%96%E5%85%B7%E6%9C%89%E7%A1%AE%E5%AE%9A%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">使用bind方法提取具有确定接收者的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8bind%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">使用bind实现函数柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E4%BF%A1%E8%B5%96%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84toString%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">不要信赖函数对象的toString方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E9%9D%9E%E6%A0%87%E5%87%86%E7%9A%84%E6%A0%88%E6%A3%80%E6%9F%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text">避免使用非标准的栈检查属性</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://sdongzhi.com/2018/09/11/read-book-effective-six/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="多弗朗明哥"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="唐吉诃德的小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Effective JavaScript (六)<a class="post-edit-link" href="https://github.com/YunYouJun/yunyoujun.github.io/tree/hexo/source/_posts/read-book-effective-six.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2018-09-11 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-11T00:00:00+00:00">2018-09-11</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-09-27 06:34:37" itemprop="dateModified" datetime="2021-09-27T06:34:37+00:00">2021-09-27</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">2.5k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">10m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">读书总结</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/javascript/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">javascript</span></a><a class="tag-item" href="/tags/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">读书总结</span></a></span></div><div class="post-author"><span class="author-name">toshiba</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>理解函数调用， 方法调用，构造函数调用之间的不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最简单的函数调用</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;hello, &quot;</span> + username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello(<span class="string">&quot;Keyser soze&quot;</span>);</span><br><span class="line"></span><br><span class="line">方法调用</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">hello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello, &quot;</span> + <span class="built_in">this</span>.username;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">username</span>: <span class="string">&quot;Hans, Gruber&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.hello(); <span class="comment">// hello, Hans, Gruber</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用过程中由调用表达式自身来确定this变量的绑定。 </span></span><br><span class="line">  </span><br><span class="line">构造函数调用</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, pass</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.pass = pass;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> User(<span class="string">&quot;sketcon&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">与函数调用和方法调用不同的是，构造函数调用将一个全新的对象作为<span class="built_in">this</span>变量的值，并隐式的返回这个对象作为调用结果。</span><br><span class="line">构造函数的主要职责是初始化这个新对象。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="熟练掌握高阶函数"><a href="#熟练掌握高阶函数" class="headerlink" title="熟练掌握高阶函数"></a>熟练掌握高阶函数</h2><p>高阶函数无非就是将函数作为参数或返回值的函数。将函数作为参数通常称为回调函数。</p>
<h2 id="使用call方法自定义接收者来调用方法"><a href="#使用call方法自定义接收者来调用方法" class="headerlink" title="使用call方法自定义接收者来调用方法"></a>使用call方法自定义接收者来调用方法</h2><p>通常情况下，函数或方法的接接收者（即绑定到特殊关键字this的值）是由调用者的语法决定的。但是有时我需要自定义一个接收者，幸运的是函数有一个内置的方法call来自定义接收者。可以通过函数对象的call方法来调用自身。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.call(obj, arg1, arg2, arg3);</span><br><span class="line"></span><br><span class="line">f(arg1, arg2, arg3);</span><br></pre></td></tr></table></figure>
<p>不同的是第一个参数提供了一个显示的接收者对象。</p>
<h2 id="使用apply方法通过不同数量的参数调用函数"><a href="#使用apply方法通过不同数量的参数调用函数" class="headerlink" title="使用apply方法通过不同数量的参数调用函数"></a>使用apply方法通过不同数量的参数调用函数</h2><p>这里理解有误区，接受一个数组的参数，但是方法调用时将参数依次传入方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">average 函数是一个称为可变参数或可变元的函数（函数的元市值其期望的参数个数）</span><br><span class="line"></span><br><span class="line">average(1, 2, 3);</span><br><span class="line"></span><br><span class="line">average(1);</span><br><span class="line"></span><br><span class="line">average(1, 2, 3, 7, 9);</span><br><span class="line"></span><br><span class="line">可变参数的版本更加简洁，优雅。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">averageOfArray([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">averageOfArray([1]);</span><br><span class="line"></span><br><span class="line">averageOfArray([1, 2, 3, 7, 9]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 本来average 只接受可变参数，假设我有这样一个数字数组， average函数中没有this引用，所以简单的传null就可以。</span><br><span class="line">var scores = getAllScores();</span><br><span class="line">average.apply(null, scores)  </span><br><span class="line">传入一个数组，调用时这样 average(scores[0], scores[1], scores[2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用apply方法指定一个可计算的参数数组来调用可变参数的函数。</span><br><span class="line">使用apply方法的第一个参数给可变参数的方法提供一个接收者。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="使用arguments创建可变参数的函数"><a href="#使用arguments创建可变参数的函数" class="headerlink" title="使用arguments创建可变参数的函数"></a>使用arguments创建可变参数的函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">参数可变函数的实现</span><br><span class="line">function average() &#123;</span><br><span class="line">	for(var i = 0, sum = 0, n = argumants.length; i &lt; n; i++) &#123;</span><br><span class="line">		sum += arguments[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return sum / n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可变参数的函数提供了灵活的接口，不同的调用者可以使用不同数量的参数来调用它们，但是它们自身也失去了一点便利。如果使用者要使用数组的参数则只能使用 apply。<br>apply方法会降低可读性而且经常导致性能损失</p>
<p>好的经验是</p>
<blockquote>
<p>如果提供了一个便利的可变参数的函数，最好也提供一个需要显示指定数组的固定元数的版本。这样可以编写一个轻量级的封装，并委托固定元数的版本来实现可变参数的函数</p>
</blockquote>
<p>比较拗口，代码比较直观如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">固定元数的版本实现 用来作为数组参数的调用</span><br><span class="line">function averageOfArray(a) &#123;</span><br><span class="line">	for(var i = 0, sum = 0, n = a.length; i &lt; n; i++) &#123;</span><br><span class="line">		sum += a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return sum / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">averageOfArray([1, 2, 3]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数可变函数的实现可以通过调用 固定元数版本来实现</span><br><span class="line">function average() &#123;</span><br><span class="line">	// averageOfArray本来就支持数组 所以无论average传入数组还是啥</span><br><span class="line">	return averageOfArray(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="永远不要修改arguments对象"><a href="#永远不要修改arguments对象" class="headerlink" title="永远不要修改arguments对象"></a>永远不要修改arguments对象</h2><p>不要修改arguments对象，并且将arguments对象复制到一个真正的数组中再进行调整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">	add: function(x, y) &#123; return x + y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function callMethod(obj, method) &#123;</span><br><span class="line">	var shift = [].shift;</span><br><span class="line">	shift.call(arguments);</span><br><span class="line">	shift.call(arguments);</span><br><span class="line"></span><br><span class="line">	return obj[method].apply(obj, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callMethod(obj, &quot;add&quot;, 17, 25);  // cannot read property &quot;apply&quot; of undefined   17[25]</span><br><span class="line"></span><br><span class="line">这里的arguments 对象并不是函数参数的副本，所有命名参数都是arguments对象中对应索引的别名。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>永远不要修改arguments对象是更为安全的，通过一开始复制参数中的元素到一个真正的数组的方式，很容易避免修改arguments对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var args = [].slice.call(argumants);</span><br><span class="line"></span><br><span class="line">slice会复制整个数组，其结果是一个真正的标准Array类型实例。</span><br><span class="line"></span><br><span class="line">function callMethod(obj, method) &#123;</span><br><span class="line">	var args = [].slice.call(arguments, 2);</span><br><span class="line">	return obj[method].apply(obj, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callMethod(obj, &quot;add&quot;, 17, 25);</span><br></pre></td></tr></table></figure>

<h2 id="使用变量保存arguments的引用"><a href="#使用变量保存arguments的引用" class="headerlink" title="使用变量保存arguments的引用"></a>使用变量保存arguments的引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 实现一个迭代器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function values() &#123;</span><br><span class="line">	var i = 0, n = arguments.length;</span><br><span class="line">	return &#123;</span><br><span class="line">		hasNext: function() &#123;</span><br><span class="line">			return i &lt; n;</span><br><span class="line">		&#125;,</span><br><span class="line">		next: function() &#123;</span><br><span class="line">			if(i &gt;= n) &#123;</span><br><span class="line">				throw new Error(&quot;end of iteration&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return arguments[i++]; // wrong arguments;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = values(1, 2, 3, 5, 78);</span><br><span class="line"></span><br><span class="line">it.next(); //undefined</span><br><span class="line"></span><br><span class="line">it.next(); //undefined</span><br><span class="line"></span><br><span class="line">it.next(); //undefined</span><br><span class="line"></span><br><span class="line">每次调用next的时候，next方法内部会存在一个arguments这里可能我们关心的只是values的arguments, 所以正确的方法是将values的arguments保存下来</span><br><span class="line"></span><br><span class="line">function values() &#123;</span><br><span class="line">	var i = 0, n = arguments.length, arg = arguments;</span><br><span class="line">	return &#123;</span><br><span class="line">		hasNext: function() &#123;</span><br><span class="line">			return i &lt; n;</span><br><span class="line">		&#125;,</span><br><span class="line">		next: function() &#123;</span><br><span class="line">			if(i &gt;= n) &#123;</span><br><span class="line">				throw new Error(&quot;end of iteration&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return arg[i++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用bind方法提取具有确定接收者的方法"><a href="#使用bind方法提取具有确定接收者的方法" class="headerlink" title="使用bind方法提取具有确定接收者的方法"></a>使用bind方法提取具有确定接收者的方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var buffer = &#123;</span><br><span class="line">	entries: [],</span><br><span class="line">	add: function(s) &#123;</span><br><span class="line">		this.entries.push(s);</span><br><span class="line">	&#125;,</span><br><span class="line">	concat: function() &#123;</span><br><span class="line">		return this.entries.join(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];</span><br><span class="line"></span><br><span class="line">source.forEach(buffer.add);  // error: entries is undefined</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>buffer.add 方法的接收者并不是buffer对象，函数的接收者取决于它是如何被调用，<br>不过我们并没有调用它，而是把它传给了forEach方法<br>而我们并不知道forEach在哪里调用了它，事实上forEach方法的实现使用全局对象作为默认的接收者。由于全局对象没有entries属性所以这段代码抛出了一个错误。<br>幸运的是forEach允许调用者提供一个可选的参数作为回调函数的接收者，所以我们可以很轻松的修复该例子。</p>
<p>方法一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];</span><br><span class="line"></span><br><span class="line">source.forEach(buffer.add, buffer); </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>并非所有的高阶函数都会为使用者提供其毁掉函数的接收者。如果forEach不接受额外的接收者参数怎么办</p>
<p>方法二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source.forEach(function(s) &#123;</span><br><span class="line">	buffer.add(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bujjer.join();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个函数用来实现绑定其接收者到一个指定的对象是非常常见的，因此ES5标准库直接支持这种模式，函数对象的bind方法需要一个接收者对象，并产生一个以该接收者对象的方法调用的方式调用原来的函数的封装函数。</p>
<p>方法三</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var source = [&quot;867&quot;, &quot;-&quot;, &quot;5309&quot;];</span><br><span class="line"></span><br><span class="line">source.forEach(buffer.add.bind(buffer)); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buffer.add.bind(buffer) 创建了一个新函数而不是修改了bufffer.add函数 该函数将接收者绑定到了buffer对象，而原有函数的接收者保持不变</span><br><span class="line"></span><br><span class="line">buffer.add === buffer.add.bind(buffer);  // false;</span><br></pre></td></tr></table></figure>

<h2 id="使用bind实现函数柯里化"><a href="#使用bind实现函数柯里化" class="headerlink" title="使用bind实现函数柯里化"></a>使用bind实现函数柯里化</h2><p>函数对象的bind方法除了具有降方法绑定到接收者的用途外，它还有更多功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function simpleURL(protocol, domain, path) &#123;</span><br><span class="line">	return protocol + &quot;://&quot; + domain + &quot;/&quot; + path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var urls = paths.map(function(path) &#123;</span><br><span class="line">	return simpleURL(&quot;http&quot;, siteDomain, path);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传给simpleURL的前两个参数是固定的， 只有第三个参数在变化，我们可以通过调用simpleURL函数的bind方法来自动构造该匿名函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var urls = path.map(simpleURL.bind(null, &quot;http&quot;, siteDomain));</span><br></pre></td></tr></table></figure>
<p>对simpleURL.bind的调用产生了一个委托到simpleURL的新函数，bind的第一个参数提供了接收者的值， 由于simpleURL.bind不需要引用this，所以可以使用任何值。使用null和undefined是习惯用法。 simpleURL.bind的其余参数和提供给你新函数的所有参数共同组成了传递给simpleURL的参数。</p>
<blockquote>
<p>将函数与其参数的一个子集绑定的技术称为函数柯里化。</p>
</blockquote>
<h2 id="不要信赖函数对象的toString方法"><a href="#不要信赖函数对象的toString方法" class="headerlink" title="不要信赖函数对象的toString方法"></a>不要信赖函数对象的toString方法</h2><p>JavaScript有一个非凡的特性， 即将其源代码重现为字符串的能力</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(x) &#123; </span><br><span class="line">	return x + 1 </span><br><span class="line">&#125;).toString();</span><br><span class="line"></span><br><span class="line">// &quot;function (x) &#123;\n return x + 1; \n&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>ECMAScript标准对于函数对象的toString方法的返回结果并没有任何要求。这意味着不同的JavaScript引擎将产生不同的结果，甚至产生的字符串跟函数并不相关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(x) &#123; </span><br><span class="line">	return x + 1 </span><br><span class="line">&#125;).bind(16).toString();</span><br><span class="line"></span><br><span class="line">// &quot;function (x) &#123;\n [native code] \n&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>由于bind函数通常是由其他语言实现的通常c++，宿主提供一个编译后的函数，在此环境下通常没有源代码可展示。</p>
<p>还有一点就是 toString方法生成的源代码并不展示闭包中保存的和内部变量引用相关的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(x) &#123;</span><br><span class="line">	return function(y) &#123;</span><br><span class="line">		return x + y;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;)(42).toString();</span><br><span class="line"></span><br><span class="line">// &quot;function(y) &#123;\n return x + y; \n &#125;&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总而言之，应该避免使用函数对象的toString方法</p>
</blockquote>
<h2 id="避免使用非标准的栈检查属性"><a href="#避免使用非标准的栈检查属性" class="headerlink" title="避免使用非标准的栈检查属性"></a>避免使用非标准的栈检查属性</h2><ul>
<li>arguments.callee 指向使用该arguments对象被调用的函数</li>
<li>arguments.caller 指向调用该arugments对象的函数（该arguments对象调用函数的函数）</li>
</ul>
<p>出于安全考虑大多环境移除了arguments.caller,因此它是不可靠的</p>
<p>许多JavaScript环境提供了一个相似的函数对象属性—非标准但是普遍适用的caller属性。 它指向函数最近的调用者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function revealCaller() &#123;</span><br><span class="line">	return revealCaller.caller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start() &#123;</span><br><span class="line">	return revealCaller();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start() === start;  // true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES5的严格模式禁止使用arguments.caller 和arguments.callee ，因为它们不具备良好的可移植性， 非标准的函数对象caller属性应该避免使用，因为在包含全部栈信息方面，它是不可靠的。</p>
</blockquote>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>toshiba</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://sdongzhi.com/2018/09/11/read-book-effective-six/" title="Effective JavaScript (六)">https://sdongzhi.com/2018/09/11/read-book-effective-six/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2018/09/11/read-book-effective-five/" rel="prev" title="Effective JavaScript (五)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Effective JavaScript (五)</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2018/06/27/read-book-effective-four/" rel="next" title="Effective JavaScript (四)"><span class="post-nav-text">Effective JavaScript (四)</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br></div><div id="disqus_thread"></div><script>const disqusConfig = function() {
  this.page.url = "https://sdongzhi.com/2018/09/11/read-book-effective-six/"; // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = "2018/09/11/read-book-effective-six/"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  this.page.title = "Effective JavaScript (六)";
};
function loadDisqus() {
  // here we will only load the disqus <script> if not already loaded
  if (!window.DISQUS) {
    (function() {
      // DON'T EDIT BELOW THIS LINE
      const d = document,
        s = d.createElement("script");
      s.src = "https://IORI.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
  // if disqus <script> is already loaded, we just reset disqus the right way
  // see https://help.disqus.com/developer/using-disqus-on-ajax-sites
  else {
    DISQUS.reset({
      reload: true,
      config: function() {
        this.page.identifier = disqusConfig.page.identifier;
        this.page.url = disqusConfig.page.url;
      },
    });
  }
}</script><script src="/js/comments/disqus.js"></script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2017 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 多弗朗明哥</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script defer src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-tag-common@latest/js/index.js"></script><!-- hexo injector body_end end --></body></html>