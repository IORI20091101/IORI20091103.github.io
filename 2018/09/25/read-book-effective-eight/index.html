<!DOCTYPE html><html lang="zh-CN"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-tag-common@latest/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="多弗朗明哥"><meta name="copyright" content="多弗朗明哥"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>Effective JavaScript (八) | 唐吉诃德的小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" href="https://cdn.darknights.cn/assets/images/favicon.ico"><link rel="mask-icon" href="https://cdn.darknights.cn/assets/images/favicon.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"sdongzhi.com","root":"/","title":"唐吉诃德的小站","version":"1.6.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"algolia":{"appID":"ZH3RNMJ8TX","apiKey":"d3c4e9cb3d4b25b901414d257a20d970","indexName":"Pages","hits":{"per_page":8}},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="唐吉诃德的小站" type="application/atom+xml"><link rel="stylesheet" href="/styles/custom.css"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=UA-107257239-1"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107257239-1');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="使用Object的直接实例构造轻量级的字典12345678910var dict &#x3D; &amp;#123; alice: 34, bob: 24, chris: 62 &amp;#125;;var people &#x3D; [];for(var name in dict) &amp;#123;	people.push(name + &quot;: &quot; + dict[name]);&amp;#125;people; &#x2F;&#x2F; [&amp;q">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective JavaScript (八)">
<meta property="og:url" content="https://sdongzhi.com/2018/09/25/read-book-effective-eight/index.html">
<meta property="og:site_name" content="唐吉诃德的小站">
<meta property="og:description" content="使用Object的直接实例构造轻量级的字典12345678910var dict &#x3D; &amp;#123; alice: 34, bob: 24, chris: 62 &amp;#125;;var people &#x3D; [];for(var name in dict) &amp;#123;	people.push(name + &quot;: &quot; + dict[name]);&amp;#125;people; &#x2F;&#x2F; [&amp;q">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-09-25T00:00:00.000Z">
<meta property="article:modified_time" content="2021-09-26T09:54:12.689Z">
<meta property="article:author" content="多弗朗明哥">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="读书总结">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="多弗朗明哥"><img width="96" loading="lazy" src="/images/avatar.jpeg" alt="多弗朗明哥"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">多弗朗明哥</a></div><a class="site-name" href="/about/site.html">唐吉诃德的小站</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">54</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">36</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/IORI20091101" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/iori20091101" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/donduffy" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:sdzzlyjy@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Object%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AE%9E%E4%BE%8B%E6%9E%84%E9%80%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E5%AD%97%E5%85%B8"><span class="toc-number">1.</span> <span class="toc-text">使用Object的直接实例构造轻量级的字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8null%E5%8E%9F%E5%9E%8B%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toc-number">2.</span> <span class="toc-text">使用null原型以防止原型污染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8hasOwnProperty%E6%96%B9%E6%B3%95%E9%81%BF%E5%85%8D%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toc-number">3.</span> <span class="toc-text">使用hasOwnProperty方法避免原型污染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E8%80%8C%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%9D%A5%E5%AD%98%E5%82%A8%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">使用数组而不要使用字典来存储有序集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E4%B8%8D%E8%A6%81%E5%9C%A8Object-prototype%E4%B8%AD%E5%A2%9E%E5%8A%A0%E5%8F%AF%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">绝不要在Object.prototype中增加可枚举属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%9C%A8%E6%9E%9A%E4%B8%BE%E6%9C%9F%E9%97%B4%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">避免在枚举期间修改对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8for%E5%BE%AA%E7%8E%AF%E8%80%8C%E4%B8%8D%E6%98%AFfor-in"><span class="toc-number">7.</span> <span class="toc-text">数组迭代优先使用for循环而不是for...in</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%E7%94%B1%E4%BA%8E%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.</span> <span class="toc-text">迭代方法由于循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8A%E5%A4%8D%E7%94%A8%E9%80%9A%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">在类数组对象上复用通用的数组方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F%E4%BC%98%E4%BA%8E%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">数组字面量优于数组构造函数</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://sdongzhi.com/2018/09/25/read-book-effective-eight/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="多弗朗明哥"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="唐吉诃德的小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Effective JavaScript (八)<a class="post-edit-link" href="https://github.com/YunYouJun/yunyoujun.github.io/tree/hexo/source/_posts/read-book-effective-eight.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2018-09-25 00:00:00" itemprop="dateCreated datePublished" datetime="2018-09-25T00:00:00+00:00">2018-09-25</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-09-26 09:54:12" itemprop="dateModified" datetime="2021-09-26T09:54:12+00:00">2021-09-26</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">4.9k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">21m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">读书总结</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/javascript/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">javascript</span></a><a class="tag-item" href="/tags/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">读书总结</span></a></span></div><div class="post-author"><span class="author-name">toshiba</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="使用Object的直接实例构造轻量级的字典"><a href="#使用Object的直接实例构造轻量级的字典" class="headerlink" title="使用Object的直接实例构造轻量级的字典"></a>使用Object的直接实例构造轻量级的字典</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var dict = &#123; alice: 34, bob: 24, chris: 62 &#125;;</span><br><span class="line"></span><br><span class="line">var people = [];</span><br><span class="line"></span><br><span class="line">for(var name in dict) &#123;</span><br><span class="line">	people.push(name + &quot;: &quot; + dict[name]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people; // [&quot;alice: 34&quot;, &quot;bob: 24&quot;, &quot;chris: 62&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创建一个自定义的字典类会怎样呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function NaiveDict() &#123;&#125;</span><br><span class="line"></span><br><span class="line">NaiveDict.prototype.count = function() &#123;</span><br><span class="line">	var i = 0;</span><br><span class="line">	for(var name in this) &#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NaiveDict.prototype.toString = function() &#123;</span><br><span class="line">	return &quot;[object NaiveDict]&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var dict = new NaiveDict();</span><br><span class="line"></span><br><span class="line">dict.alice = 34;</span><br><span class="line">dict.bob = 24;</span><br><span class="line">dict.chris = 62;</span><br><span class="line"></span><br><span class="line">dict.count(); // 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样有一个问题，count会枚举出所有的属性包括了toString 和count,而不仅仅是我们需要的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dict = new Array();</span><br><span class="line"></span><br><span class="line">dict.alice = 34;</span><br><span class="line">dict.bob = 24;</span><br><span class="line">dict.chris = 62;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样也会有问题，代码对原型污染很脆弱，应用程序的其他库有可能会打猴子补丁，比如</p>
<blockquote>
<p>原型污染是指当枚举字典的条目时，原型对象中的一些属性可能会导致出现一些不期望的属性。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.first = function() &#123;</span><br><span class="line">	return this[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.last = function() &#123;</span><br><span class="line">	return this[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var names = [];</span><br><span class="line">for(var name in dict) &#123;</span><br><span class="line">	names.push(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">names; [&quot;alice&quot;, &quot;bob&quot;, &quot;chris&quot;, &quot;first&quot;, &quot;last&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用使用 <code>new Object() </code>可能会面临同样的问题，但是使用 <code>&#123;&#125;</code>的方式会更好, 虽然不能保证对于原型污染时安全的，任何人仍然能增加属性到Object.prototype，但是风险可以降低到仅仅局限于Object.prototype</p>
<ul>
<li>坚持使用Object的直接实例原则可以使for…in循环摆脱原型污染的影响</li>
<li>使用对象字面量构建轻量级字典</li>
</ul>
<h2 id="使用null原型以防止原型污染"><a href="#使用null原型以防止原型污染" class="headerlink" title="使用null原型以防止原型污染"></a>使用null原型以防止原型污染</h2><p>防止原型污染的最简单的方式之一就是一开始就不使用原型。但是ES5发布之前并没有一个标准的方式创建一个空原型的新对象。你可能会这样做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function C() &#123; &#125;</span><br><span class="line"></span><br><span class="line">C.prototype = null;</span><br><span class="line"></span><br><span class="line">var o = new C();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(o) === null; // false</span><br><span class="line">Object.getPrototypeOf(o) === Object.prototype // true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// ES5之后应该这样做</span><br><span class="line">var x = Object.create(null);</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(o) === null; // true</span><br><span class="line"></span><br><span class="line">在不支持Object.create的JavaScript环境中特殊对象__proto__提供了对对象内部原型链的读写访问</span><br><span class="line"></span><br><span class="line">var x = &#123; __proto__: null &#125;;</span><br><span class="line"></span><br><span class="line">x instanceof Object;  // false;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二种貌似更方便，但是有了Object.create函数后，Object.create是更值得推荐的方式。</p>
<ul>
<li>在ES5中要使用Object.create(null)创建自由原型的空对象是不太容易被污染的。</li>
<li>在一些老环境中考虑使用{ <strong>proto</strong>: null }， 但是它既不是标准的也不是可移植的还有可能在未来被删除</li>
<li>绝对不要使用__proto__作为字典中的key</li>
</ul>
<h2 id="使用hasOwnProperty方法避免原型污染"><a href="#使用hasOwnProperty方法避免原型污染" class="headerlink" title="使用hasOwnProperty方法避免原型污染"></a>使用hasOwnProperty方法避免原型污染</h2><p>JavaScript的对象操作总是以继承的方式工作，即使一个空的对象字面量也继承了Object.prototype的大量属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dict = &#123;&#125;</span><br><span class="line">&quot;alice&quot; in dict; //false;</span><br><span class="line">&quot;bob&quot; in dict; //false;</span><br><span class="line">&quot;chris&quot; in dict; //false;</span><br><span class="line"></span><br><span class="line">// toString 和valueOf方法继承自Object.prototype</span><br><span class="line">&quot;toString&quot; in dict; //false;  </span><br><span class="line">&quot;valueOf&quot; in dict; //false;</span><br></pre></td></tr></table></figure>
<p>幸运的是Object.hasOwnProperty方法可以用来判断属性是否继承自原型对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict.hasOwnProperty(&quot;alice&quot;);     // false</span><br><span class="line">dict.hasOwnProperty(&quot;toString&quot;);  // false</span><br><span class="line">dict.hasOwnProperty(&quot;valueOf&quot;);   // false</span><br></pre></td></tr></table></figure>
<p>不幸的是我们没有完全解决问题，当调用dict.hasOwnProperty时，我们请求调查对象的hasOwnProperty方法，通常情况下，该方法会简单的继承自Object.property对象，然而如果字典中存储一个同名的条目时，那么原型中的hasOwnProperty方法不能再被捕获到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict.hasOwnProperty = 10;</span><br><span class="line"></span><br><span class="line">dict.hasOwnProperty(&quot;alice&quot;);</span><br><span class="line">// error dict.hasOwnProperty is not a function</span><br></pre></td></tr></table></figure>
<p>这是有可能的,最安全的方式就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var hasOwn = Object.prototype.hasOwnProperty;</span><br><span class="line">或者</span><br><span class="line">var hasOwn = &#123;&#125;.hasOwnProperty;</span><br><span class="line"></span><br><span class="line">hasOwn.call(dict, &quot;alice&quot;);</span><br></pre></td></tr></table></figure>
<p>不管起接收者的hasOwnProperty方法是否被覆盖，该方法都能工作。</p>
<p>我们开始创建一个字典类 版本一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Dict(elements) &#123;</span><br><span class="line">	this.elements = elements || &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dict.prototype.has = function(key) &#123;</span><br><span class="line">	return &#123;&#125;.hasOwnProperty.call(this.elements, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dict.prototype.get = function(key) &#123;</span><br><span class="line">	return this.has(key) ? this.elements[key] : undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dict.prototype.set = function(key, val) &#123;</span><br><span class="line">	this.elements[key] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dict.prototype.remove = function(key) &#123;</span><br><span class="line">	delete this.elements[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dict = new Dict(&#123;</span><br><span class="line">	alice: 34,</span><br><span class="line">	bob: 24,</span><br><span class="line">	chris: 62</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dict.has(&quot;alice&quot;);    // true</span><br><span class="line">dict.get(&quot;bob&quot;);      // 24</span><br><span class="line">dict.has(&quot;valueOf&quot;)   //false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在一些JavaScript的环境中，特殊的属性名__proto__可能导致自身的污染问题__proto__属性只是简单的继承Object.prototype,所以我们的例子会有一个问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var dict = new Dict();</span><br><span class="line">dict.has(&quot;__proto__&quot;); // ?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码在不同的环境下可能会有不同的结果，所以为了达到最大的可移植性和安全性，便有了下面更复杂但是更安全的实现<br>这里检测到__proto__的可以 重新设置一个新属性作为实例对象的一个属性，随对象而在但是不会去设置对象的__proto__</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">function Dict(elements) &#123;</span><br><span class="line">	this.elements = elements || &#123;&#125;;</span><br><span class="line">	this.hasSpecialProto = false;</span><br><span class="line">	this.specialProto = undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dict.prototype.has = function(key) &#123;</span><br><span class="line">	if(key === &quot;__proto__&quot;) &#123; </span><br><span class="line">		return this.hasSpecialProto;</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123;&#125;.hasOwnProperty.call(this.elements, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dict.prototype.get = function(key) &#123;</span><br><span class="line">	if(key === &quot;__proto__&quot;) &#123; </span><br><span class="line">		return this.specialProto;</span><br><span class="line">	&#125;</span><br><span class="line">	return this.has(key) ? this.elements[key] : undefined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dict.prototype.set = function(key, val) &#123;</span><br><span class="line">	if(key === &quot;__proto__&quot;) &#123;</span><br><span class="line">		this.hasSpecialProto = true;</span><br><span class="line"></span><br><span class="line">		this.specialProto = val;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		this.elements[key] = val;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dict.prototype.remove = function(key) &#123;</span><br><span class="line">	if(key === &quot;__proto__&quot;) &#123;</span><br><span class="line">		this.hasSpecialProto = false;</span><br><span class="line">		this.sepcialProto = undefined;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		delete this.elements[key];	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var dict = new Dict(&#123;</span><br><span class="line">	alice: 34,</span><br><span class="line">	bob: 24,</span><br><span class="line">	chris: 62</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dict.has(&quot;alice&quot;);    // true</span><br><span class="line">dict.get(&quot;bob&quot;);      // 24</span><br><span class="line">dict.has(&quot;valueOf&quot;)   //false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用数组而不要使用字典来存储有序集合"><a href="#使用数组而不要使用字典来存储有序集合" class="headerlink" title="使用数组而不要使用字典来存储有序集合"></a>使用数组而不要使用字典来存储有序集合</h2><p>JavaScript对象是一个无序集合,ECMAScript标准并未规定属性存储的任何特定顺序，甚至对于枚举对象也未涉及。这将会导致一个问题，<code>for...in</code>循环会挑选一个特定顺序来枚举对象属性.比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function report(highScores) &#123;</span><br><span class="line">	var result = &quot;&quot;;</span><br><span class="line">	var i = 1;</span><br><span class="line">	for(var name in highScores) &#123;</span><br><span class="line">		result += i + &quot; . &quot; + name + &quot; : &quot; + highScores[name] + &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">report([&#123;</span><br><span class="line">		name: &quot;Hank&quot;,</span><br><span class="line">		points: 1110100</span><br><span class="line">	&#125;,&#123;</span><br><span class="line">		name: &quot;Steve&quot;,</span><br><span class="line">		points: 1064500</span><br><span class="line">	&#125;,&#123;</span><br><span class="line">		name: &quot;Billy&quot;,</span><br><span class="line">		points: 1052000</span><br><span class="line">	&#125;]);</span><br><span class="line"></span><br><span class="line">由于不同的环境选择不同的顺序来存储和枚举对象属性，所以这个函数得到顺序混乱的“最高分”报表</span><br></pre></td></tr></table></figure>
<p>请记住你的程序是否以来对象枚举的顺序并不总是显而易见的，如果没有在多个JavaScript环境中测试过你的程序，你甚至可能不回注意到程序的行为因为一个for…in循环的确切顺序而被改变，对于上面的例子需要使用数组,那么它完全可以工作在任何JavaScript环境中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function report(highScores) &#123;</span><br><span class="line">	var result = &quot;&quot;;</span><br><span class="line">	var i = 1;</span><br><span class="line">	for(var i = 0, n = highScores.length; i &lt; n; i++) &#123;</span><br><span class="line">		var score = hightScores[i];</span><br><span class="line">		result += (i + 1) + &quot; . &quot; + score.name + &quot; : &quot; + score.points + &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">report([&#123;</span><br><span class="line">		name: &quot;Hank&quot;,</span><br><span class="line">		points: 1110100</span><br><span class="line">	&#125;,&#123;</span><br><span class="line">		name: &quot;Steve&quot;,</span><br><span class="line">		points: 1064500</span><br><span class="line">	&#125;,&#123;</span><br><span class="line">		name: &quot;Billy&quot;,</span><br><span class="line">		points: 1052000</span><br><span class="line">	&#125;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个微妙的顺序以来的典型例子是浮点运算， 假设一个对象使用<code>for...in</code> 如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var ratings = &#123;</span><br><span class="line">	&quot;Good will Hunting&quot;: 0.8,</span><br><span class="line">	&quot;Mystic River&quot;: 0.7,</span><br><span class="line">	&quot;21&quot;: 0.6,</span><br><span class="line">	&quot;Doubt&quot;: 0.9</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var total = 0, count = 0;</span><br><span class="line">for(var key in. ratings) &#123;</span><br><span class="line">	total += ratings[key];</span><br><span class="line">	count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total /= count;</span><br><span class="line"></span><br><span class="line">total; //?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>事实证明，流行的JavaScrtip环境实际上使用不同的顺序执行这个循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一些环境这样计算</span><br><span class="line"></span><br><span class="line">(0.8 + 0.7 + 0.6 + 0.9) / 4  // 0.75</span><br><span class="line"></span><br><span class="line">还有一些环境先枚举潜在的数组索引，21恰好是一个可行的数组索引，它首先被枚举，导致如下结果</span><br><span class="line"></span><br><span class="line">(0.6 + 0.8 + 0.7 + 0.9) / 4  // 0.7499999999999999</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">更好的表示方法是使用整数值</span><br><span class="line"></span><br><span class="line">(8 + 7 + 6 + 9) / 4/ 10.  //0.75</span><br><span class="line"></span><br><span class="line">(6 + 8 + 7  + 9) / 4/ 10.  //0.75</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常当执行<code>for...in</code> 循环时应当时刻小心，确保操作行为与顺序无关。</p>
<h2 id="绝不要在Object-prototype中增加可枚举属性"><a href="#绝不要在Object-prototype中增加可枚举属性" class="headerlink" title="绝不要在Object.prototype中增加可枚举属性"></a>绝不要在Object.prototype中增加可枚举属性</h2><p><code>for...in</code>非常便利，然而它很容易受到原型污染的影响。目前为止<code>for...in</code>最常见的用法是枚举字典中的元素。这暗示着如果想允许对字典对象使用<code>for...in</code>循环，那么不要在共享的Object.prototype中增加可枚举的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.allKeys = function() &#123;</span><br><span class="line">	var result = [];</span><br><span class="line">	for(var key in this) &#123;</span><br><span class="line">		result.push(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(&#123;a: 1, b: 2, c: 3&#125;).allKeys(); // [&quot;allkeys&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]  该方法污染了自身</span><br><span class="line"></span><br><span class="line">更友好的做法是将allkeys定义为一个函数而不是方法，虽然着稍微有点不方便</span><br><span class="line"></span><br><span class="line">function allKeys(obj) &#123;</span><br><span class="line">	var result = [];</span><br><span class="line">	for(var key in obj) &#123;</span><br><span class="line">		result.push(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你确实想在Object.prototype中增加属性， ES5提供了一个更加友好的机制Object.defineProperty</p>
<blockquote>
<p><code>Object.defineProperty</code>方法可以定义一个对象的属性并制定该属性的元数据。例如，我们可以用与之前完全一样的方法定义上面的属性而通过设置其可枚举属性为false使其在<code>for...in</code>循环中不可见。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Object.prototype, &quot;allKeys&quot;, &#123;</span><br><span class="line">	value: function() &#123;</span><br><span class="line">		var result = [];</span><br><span class="line">		for(var key in this) &#123;</span><br><span class="line">			result.push(key);</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;,</span><br><span class="line">	writable: true,</span><br><span class="line">	enumerable: false,</span><br><span class="line">	configurable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>它不会污染其他所有<code>Object</code>实例的所有<code>for...in</code>循环。每当你需要增加一个不应该出现在<code>for...in</code>循环中出现的属性时，Object.defineProperty便是你的选择</p>
<h2 id="避免在枚举期间修改对象"><a href="#避免在枚举期间修改对象" class="headerlink" title="避免在枚举期间修改对象"></a>避免在枚举期间修改对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Member(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.friends = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Member(&quot;Alice&quot;),</span><br><span class="line">	b = new Member(&quot;Bob&quot;),</span><br><span class="line">	c = new Member(&quot;Carol&quot;),</span><br><span class="line">	d = new Member(&quot;Dieter&quot;),</span><br><span class="line">	e = new Member(&quot;Eli&quot;),</span><br><span class="line">	f = new Member(&quot;Fatima&quot;);</span><br><span class="line"></span><br><span class="line">a.friends.push(b);</span><br><span class="line">b.friends.push(c);</span><br><span class="line">c.friends.push(e);</span><br><span class="line">d.friends.push(b);</span><br><span class="line">e.friends.push(d,f);</span><br><span class="line"></span><br><span class="line">如果我们写了一个方法 在for...in的时候操作对象比如，删除或添加， 在许多JavaScript环境中这段代码根本不能工作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ECMAScript规定了，如果被枚举的对象在枚举期间添加了新的属性，那么在枚举期间并不能保证新添加的属性能够被访问。</p>
</blockquote>
<p>这个隐式的规范的实际后果是： 如果我们修改了被枚举的对象则不能保证<code>for...in</code>循环行为的可预见性。</p>
<p>我们可以新建一个WorkSet类来追踪当前集合中元素的数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">function WorkSet() &#123;</span><br><span class="line">	this.entries = new Dict();</span><br><span class="line">	this.count = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkSet.prototype.isEmpty = function() &#123;</span><br><span class="line">	return this.count === 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkSet.prototype.add = function(key, val) &#123;</span><br><span class="line">	if(this.entries.has(key)) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.entries.set(key, val);</span><br><span class="line">	this.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkSet.prototype.get = function(key) &#123;</span><br><span class="line">	return this.entries.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkSet.prototype.remove = function(key) &#123;</span><br><span class="line">	if(!this.entries.had(key)) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.entries.remove(key);</span><br><span class="line">	this.count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkSet.prototype.pick = function() &#123;</span><br><span class="line">	return this.entries.pick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里同时需要给Dict类增加一个pick方法</span><br><span class="line"></span><br><span class="line">Dick.prototype.pick = function() &#123;</span><br><span class="line">	for(var key in this.elements) &#123;</span><br><span class="line">		if(this.has(key)) &#123;</span><br><span class="line">			return key;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	throw new Error(&quot;empty dictionary&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 现在我们可以实现一个inNetwork的方法</span><br><span class="line">到最后发现这段代码没什么卵用</span><br><span class="line">Member.prototype.inNetwork = function(other) &#123;</span><br><span class="line">	var visited = &#123;&#125;;</span><br><span class="line">	var workset = new WorkSet();</span><br><span class="line">	workset.add(this.name, this);</span><br><span class="line"></span><br><span class="line">	while(!workset.isEmpty()) &#123;</span><br><span class="line">		var name = = workset.pick();</span><br><span class="line">		var member = workset.get(name);</span><br><span class="line">		workset.remove(name);</span><br><span class="line">		if(name in visited) &#123;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		visited[name] = member;</span><br><span class="line"></span><br><span class="line">		if(member === other) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		member.friends.forEach(function(friend) &#123;</span><br><span class="line">			workset.add(friend.name, friend);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上pick方法是一个不确定性的例子， 不确定性指的是一个操作不能保证使用语言的语意产生一个单一的可预见的结果。这个不确定性来源于这样一个事实，for…in循环可能在不同的JavaScript环境中选择不同的枚举顺序。<br>基于这些原因，考虑使用一个确定的工作集算法替代方案是值得的。集工作列表算法Work-list.</p>
<ul>
<li>使用for…in循环枚举一个对象属性时，确保不要修改该对象</li>
<li>当迭代一个对象时，如果该对象的内容可能会在循环期间被改变，应该使用while循环或经典的for循环代替for…in循环</li>
<li>为了在不断变化的数据结构中能够预测枚举，考虑使用一个有序的数据结构，例如数组，而不要使用字典对象</li>
</ul>
<h2 id="数组迭代优先使用for循环而不是for-in"><a href="#数组迭代优先使用for循环而不是for-in" class="headerlink" title="数组迭代优先使用for循环而不是for...in"></a>数组迭代优先使用<code>for</code>循环而不是<code>for...in</code></h2><p>看下面代码mean的输出值时多少？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var scores = [98, 74, 85, 77, 93, 100, 89];</span><br><span class="line"></span><br><span class="line">var total = 0;</span><br><span class="line"></span><br><span class="line">for(score in scores) &#123;</span><br><span class="line">	total += score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mean = total / socres.length;</span><br><span class="line"></span><br><span class="line"> mean; // ?  17636.571428571428</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 请记住即使是数组的索引属性，对象属性的key始终是字符串</span><br><span class="line"></span><br><span class="line"> total = 0 + &quot;0&quot; + &quot;1&quot; + &quot;2&quot; + &quot;3&quot; + &quot;4&quot; + &quot;5&quot; + &quot;6&quot;;</span><br><span class="line"></span><br><span class="line"> total = &quot;00123456&quot;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>迭代数组内容的正确方式是使用传统的for循环, 建议存储数组长度到一个局部变量中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var scores = [98, 74, 85, 77, 93, 100, 89];</span><br><span class="line">var total = 0;</span><br><span class="line"></span><br><span class="line">for(var i = 0, n = scores.length; i &lt; n; i++) &#123;</span><br><span class="line">	total += socres[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var mean = toal / scores.length;</span><br><span class="line"></span><br><span class="line">mean; // 88</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="迭代方法由于循环"><a href="#迭代方法由于循环" class="headerlink" title="迭代方法由于循环"></a>迭代方法由于循环</h2><p>一些常见的for循环错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt;= n; i++) &#123;...&#125;. // 获取最后一项错误</span><br><span class="line"></span><br><span class="line">for(var i = 1; i &lt; n; i++) &#123;...&#125;. // 丢失第一项</span><br><span class="line"></span><br><span class="line">for(var i = n; i &gt;= 0 ; i--) &#123;...&#125;. // 获取起始值错误</span><br><span class="line"></span><br><span class="line">for(var i = n - 1; i &gt; 0 ; i--) &#123;...&#125;. // 丢失最后一项</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们面对这样一个事实，搞清楚终止条件是一个累赘。<br>幸运的是ES5提供了一些便利的方法。Array.prototype.forEach是其中最简单的一个。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0, n = players.length; i &lt; n; i++) &#123;</span><br><span class="line">	players[i].score++;</span><br><span class="line">&#125;</span><br><span class="line">可以用下面代码替换</span><br><span class="line">players.forEach(function(p) &#123;</span><br><span class="line">	p.socre++;</span><br><span class="line">&#125;)	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码不仅更简单可读而且消除了终止条件和任何数组索引。</p>
<p>另一个例子是对数组进行操作后建立一个新的数组我们可以这样实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var trimmed = [];</span><br><span class="line">for(var i = 0, n = input.lenght; i &lt; n; i++) &#123;</span><br><span class="line">	trimmed.push(input[i].trim());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我们同样可以使用forEach来实现</span><br><span class="line"></span><br><span class="line">var trimmed = [];</span><br><span class="line">input.forEach(function(s) &#123;</span><br><span class="line">	trimmed.push(s.trim());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为这是一个十分普遍的操作，所以ES5提供了一个更简单优雅的实现Array.prototype.map</span><br><span class="line"></span><br><span class="line">var trimmed = input.map(function(s) &#123;</span><br><span class="line">	return s.trim();	</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外一种常见的模式是计算一个新的数组，该数组只包含现有数组的一部分元素.<code>Array.prototype.filter</code>使其变得简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">listings.filter(function(listing) &#123;</span><br><span class="line">	return listing.price &gt;= min &amp;&amp; listing.price &lt;= max;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这些都是ES5的默认方法，我们当然可以实现自己的方法，比如我们需要这样一个模式，提取满足谓词的数组的前几个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function takeWhile(a, pred) &#123;</span><br><span class="line">	var result = [];</span><br><span class="line">	for(var i = 0, n = a.length; i &lt; n; i++) &#123;</span><br><span class="line">		if(!pred(a[i], i)) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		result[i] = a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var prefix = taleWhile([1, 2, 4, 8, 16, 32], function(n) &#123;</span><br><span class="line">	return n &lt; 10;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// [1, 2, 4, 8]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请注意我们将索引i赋值给了pred, 我们可以选择使用或忽略该索引。事实上标准库中的所有迭代方法包括(forEach, map, filter)都将数组索引传递给了用户自定义函数。</p>
<p>我们也可以将takeWhile加入到Array.prototype中参考猴子补丁的影响</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.takeWhile = function(pred) &#123;</span><br><span class="line">	var result = [];</span><br><span class="line">	for(var i = 0, n = this.length; i &lt; n; i++) &#123;</span><br><span class="line">		if(!pred(this[i], i)) &#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		result[i] = this[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var prefix = [1, 2, 4, 8, 16, 32].takeWhile(function(n) &#123;</span><br><span class="line">	return n &lt; 10;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>循环只有一点优于迭代函数，那就是前者有控制流操作，如break 和continue。 </p>
</blockquote>
<p>举例来说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function takeWhile(a, pred) &#123;</span><br><span class="line">	var result = [];</span><br><span class="line">	a.forEach(function(x, i) &#123;</span><br><span class="line">		if(!pred(x)) &#123;</span><br><span class="line">			// ?</span><br><span class="line">		&#125;</span><br><span class="line">		result[i] = x;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">我们可以使用一个内部异常来提前终止该循环，但是这既尴尬又效率低下</span><br><span class="line"></span><br><span class="line">function takeWhile(a, pred) &#123;</span><br><span class="line">	var result = [];</span><br><span class="line">	var earlyExit = [];</span><br><span class="line">	try &#123;</span><br><span class="line">		a.forEach(function(x, i) &#123;</span><br><span class="line">			if(!pred(x)) &#123;</span><br><span class="line">				throw earlyExit;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			result[i] = x;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; catch(e) &#123;</span><br><span class="line">		if(e !== earlyExit) &#123;</span><br><span class="line">			throw e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ES5的数组方法some和every可以用于提前终止循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1, 10, 100].some(function(x) &#123;.return x &gt; 5; &#125;);  // true</span><br><span class="line">[1, 10, 100].some(function(x) &#123;.return x &lt; 0; &#125;);  // false</span><br><span class="line"></span><br><span class="line">[1, 10, 100].every(function(x) &#123;.return x &gt; 0; &#125;);  // true</span><br><span class="line">[1, 10, 100].every(function(x) &#123;.return x &lt; 3; &#125;);  // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用这一点我们可以重新实现takeWhile方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function takeWhile(a, pred) &#123;</span><br><span class="line">	var result = [];</span><br><span class="line"></span><br><span class="line">	a.every(function(x, i) &#123;</span><br><span class="line">		if(!pred(x)) &#123;</span><br><span class="line">			return false; // break</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		result[i] = x;</span><br><span class="line">		return true;  // continue</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用迭代方法 forEach 和map替换for循环使得代码更可读，并且避免了重复循环控制逻辑</li>
<li>使用自定义的迭代函数来抽象未被标准库支持的常见循环模式</li>
<li>在需要提前终止循环的情况下， 仍然推荐使用传统的循环。另外，some和every方法也可用于提前退出</li>
</ul>
<h2 id="在类数组对象上复用通用的数组方法"><a href="#在类数组对象上复用通用的数组方法" class="headerlink" title="在类数组对象上复用通用的数组方法"></a>在类数组对象上复用通用的数组方法</h2><p><code>Array.prototype</code>中的标准方法被设计成其他对象可复用的方法，即使这些对象并没有继承Array,一个很好的例子 函数的arguments对象，它并没有继承Array.prototype，因此我们不能简单的调用arguments.forEach方法来遍历每一个参数。取而代之我们提取forEach方法对象的引用并使用其call方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 同样也可先转化为一个数组 var args = [].slice.call(arguments);</span><br><span class="line"></span><br><span class="line">function highlight() &#123;</span><br><span class="line">	[].forEach.call(arguments, function(widget) &#123;</span><br><span class="line">		widget.setBackground(&quot;yellow&quot;);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使一个对象“看起来像数组”，数组对象的基本契约总共有两个简单规则</p>
<ul>
<li>具有一个范围在0-2^32-1的整型length属性。</li>
<li>length属性大于该对象的最大索引。索引的范围是0-2^32-2的整数，它的字符串表示就是该对象的一个key</li>
</ul>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arrayLike = &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span><br><span class="line">var result = Array.prototype.map.call(arrayLike, function(s) &#123;</span><br><span class="line">	return s.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span><br></pre></td></tr></table></figure>

<p>字符串也表现为不可变的数组，因为它们是可索引的， 并且其长度也可以通过length属性获取。因此，Array.prototype中的方法操作字符串不回修改原始数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var result = Array.prototype.map.call(&quot;abc&quot;, function(s) &#123;</span><br><span class="line">	return s.toUpperCase();	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于使用Array.prototype中的方法，在增加或删除索引属性的时候它们都会强制的更新length属性。所有的Array.prototype方法在类数组中可以通用。</p>
<p>只有一个Array方法不是通用的那就是数组连接方法concat。该方法可以由任意的类数组调用但是它会检查其参数的[[Class]]属性，如果是一个真实的数组才会连接，如果不是例子如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function nameColum() &#123;</span><br><span class="line">	return [&quot;Names&quot;].concat(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namesColumn(&quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// [&quot;Names&quot;, &#123;.0: &quot;Alice&quot;, 1: &quot;Bob&quot;, 2: &quot;Chris&quot; &#125;]</span><br><span class="line"></span><br><span class="line">这种时候我们可以使用数组转换的方法</span><br><span class="line">function nameColum() &#123;</span><br><span class="line">	return [&quot;Names&quot;].concat([].slice.call(arguments));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namesColumn(&quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;);</span><br><span class="line"></span><br><span class="line">// [&quot;Names&quot;, &quot;Alice&quot;,&quot;Bob&quot;, &quot;Chris&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数组字面量优于数组构造函数"><a href="#数组字面量优于数组构造函数" class="headerlink" title="数组字面量优于数组构造函数"></a>数组字面量优于数组构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">也可以使用数组构造函数来替代</span><br><span class="line"></span><br><span class="line">var a = new Array(1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有这样几个问题</span><br><span class="line">首先要保证没有人重新包装过Array变量</span><br><span class="line">function f(Array) &#123;</span><br><span class="line">	return new Array(1, 2, 3, 4, 5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(String);  //  new String(1)</span><br><span class="line"></span><br><span class="line">其次要确保没人修改过全局Array变量</span><br><span class="line"></span><br><span class="line">Array = String;</span><br><span class="line">new Array(1, 2, 3, 4, 5); // new String(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有一个问题 </span><br><span class="line"></span><br><span class="line">[&quot;hello&quot;] 和 new Array(&quot;hello&quot;) 行为虽然一致</span><br><span class="line"></span><br><span class="line">但是</span><br><span class="line"></span><br><span class="line">[17] 和 new Array(17) 行为完全不同了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用数组字面量替代数组构造函数</li>
</ul>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>toshiba</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://sdongzhi.com/2018/09/25/read-book-effective-eight/" title="Effective JavaScript (八)">https://sdongzhi.com/2018/09/25/read-book-effective-eight/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2018/09/28/read-book-effective-ten/" rel="prev" title="Effective JavaScript (十)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Effective JavaScript (十)</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2018/09/19/read-book-effective-seven/" rel="next" title="Effective JavaScript (七)"><span class="post-nav-text">Effective JavaScript (七)</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2017 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 多弗朗明哥</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script defer src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-tag-common@latest/js/index.js"></script><!-- hexo injector body_end end --></body></html>