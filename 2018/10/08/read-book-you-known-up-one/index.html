<!DOCTYPE html><html lang="zh-CN"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-tag-common@latest/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="多弗朗明哥"><meta name="copyright" content="多弗朗明哥"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>你不知道的JavaScript上卷 | 唐吉诃德的小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" href="https://cdn.darknights.cn/assets/images/favicon.ico"><link rel="mask-icon" href="https://cdn.darknights.cn/assets/images/favicon.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"sdongzhi.com","root":"/","title":"唐吉诃德的小站","version":"1.6.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"algolia":{"appID":"ZH3RNMJ8TX","apiKey":"d3c4e9cb3d4b25b901414d257a20d970","indexName":"Pages","hits":{"per_page":8}},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="唐吉诃德的小站" type="application/atom+xml"><link rel="stylesheet" href="/styles/custom.css"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=UA-107257239-1"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-107257239-1');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="本书是读完 Effective JavaScript之后开的进行的阅读，整理自己需要注意的点。方便以后巩固。 作用域JavaScript没有块级作用域的相关功能。但是使用with、try...catch可以创建块级作用域 变量提升提升时函数优先 12345678910111213foo();var foo;foo &#x3D; function() &amp;#123;  console.log(2);&amp;#125;">
<meta property="og:type" content="article">
<meta property="og:title" content="你不知道的JavaScript上卷">
<meta property="og:url" content="https://sdongzhi.com/2018/10/08/read-book-you-known-up-one/index.html">
<meta property="og:site_name" content="唐吉诃德的小站">
<meta property="og:description" content="本书是读完 Effective JavaScript之后开的进行的阅读，整理自己需要注意的点。方便以后巩固。 作用域JavaScript没有块级作用域的相关功能。但是使用with、try...catch可以创建块级作用域 变量提升提升时函数优先 12345678910111213foo();var foo;foo &#x3D; function() &amp;#123;  console.log(2);&amp;#125;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-10-08T00:00:00.000Z">
<meta property="article:modified_time" content="2021-09-26T10:00:04.352Z">
<meta property="article:author" content="多弗朗明哥">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="读书总结">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="多弗朗明哥"><img width="96" loading="lazy" src="/images/avatar.jpeg" alt="多弗朗明哥"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">多弗朗明哥</a></div><a class="site-name" href="/about/site.html">唐吉诃德的小站</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">54</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">36</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/IORI20091101" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/iori20091101" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/donduffy" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:sdzzlyjy@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.link" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-train-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">2.</span> <span class="toc-text">变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85"><span class="toc-number">3.</span> <span class="toc-text">作用域闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.</span> <span class="toc-text">动态作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">5.</span> <span class="toc-text">块级作用域的替代方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ethis"><span class="toc-number">6.</span> <span class="toc-text">关于this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E7%9A%84%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="toc-number">7.</span> <span class="toc-text">this的绑定规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A"><span class="toc-number">7.1.</span> <span class="toc-text">默认绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="toc-number">7.2.</span> <span class="toc-text">隐式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A"><span class="toc-number">7.3.</span> <span class="toc-text">显示绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E7%BB%91%E5%AE%9A"><span class="toc-number">7.4.</span> <span class="toc-text">new绑定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%ADthis"><span class="toc-number">9.</span> <span class="toc-text">判断this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84this"><span class="toc-number">10.</span> <span class="toc-text">被忽略的this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%BC%95%E7%94%A8"><span class="toc-number">11.</span> <span class="toc-text">间接引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E8%AF%8D%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">this词法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6"><span class="toc-number">13.1.</span> <span class="toc-text">对象复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">13.2.</span> <span class="toc-text">属性描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%B8%B8%E9%87%8F"><span class="toc-number">13.3.</span> <span class="toc-text">对象常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%89%A9%E5%B1%95"><span class="toc-number">13.4.</span> <span class="toc-text">禁止扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E5%B0%81"><span class="toc-number">13.5.</span> <span class="toc-text">密封</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%BB%E7%BB%93"><span class="toc-number">13.6.</span> <span class="toc-text">冻结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Getter%E5%92%8CSetter"><span class="toc-number">13.7.</span> <span class="toc-text">Getter和Setter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E6%80%A7"><span class="toc-number">13.8.</span> <span class="toc-text">存在性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">13.9.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%A3%8E%E6%A0%BC%E7%BB%A7%E6%89%BF"><span class="toc-number">14.</span> <span class="toc-text">原型风格继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">15.</span> <span class="toc-text">委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">16.</span> <span class="toc-text">更简洁的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%AF%8D%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">反词法</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://sdongzhi.com/2018/10/08/read-book-you-known-up-one/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="多弗朗明哥"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="唐吉诃德的小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">你不知道的JavaScript上卷<a class="post-edit-link" href="https://github.com/YunYouJun/yunyoujun.github.io/tree/hexo/source/_posts/read-book-you-known-up-one.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2018-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2018-10-08T00:00:00+00:00">2018-10-08</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-09-26 10:00:04" itemprop="dateModified" datetime="2021-09-26T10:00:04+00:00">2021-09-26</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">5.1k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">22m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">读书总结</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/javascript/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">javascript</span></a><a class="tag-item" href="/tags/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">读书总结</span></a></span></div><div class="post-author"><span class="author-name">toshiba</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p>本书是读完 Effective JavaScript之后开的进行的阅读，整理自己需要注意的点。方便以后巩固。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>JavaScript没有块级作用域的相关功能。但是使用<code>with</code>、<code>try...catch</code>可以创建块级作用域</p>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>提升时函数优先</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line">var foo;</span><br><span class="line"></span><br><span class="line">foo = function() &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入结果是1，函数声明优先，同名的var变量会被忽略，但是后面的重新赋值仍然有效，第二次执行foo得到的结果就是2了。</p>
<h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line"></span><br><span class="line">  function bar() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个是闭包吗？ 从技术上来讲，也许是。但是确切的说不是。准确的说bar()对a的引用方法是词法作用域的查找规则，这些规则只是闭包的一部分。但确实是非常重要的一部分。</p>
<p>来看一个清晰的闭包例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var a = 2;</span><br><span class="line"></span><br><span class="line">  function bar() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var baz = foo();</span><br><span class="line"></span><br><span class="line">baz(); // 2  这是一个闭包的效果</span><br></pre></td></tr></table></figure>
<p>函数 bar() 的词法作用域能够访问foo() 的内部作用域。然后我们将bar()函数本身当作一个值类型进行传递， 在这个例子中，我们将bar所引用的函数对象本身当作返回值。</p>
<h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>JavaScript只有词法作用域，并没有动态作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">  var a = 3;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">bar();  // 输出结果为2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>词法作用域，让foo在查找a时，只在全局作用域找到 <code>var a = 2</code>, 所以这里显示2。 这里可能会疑惑为什么没有找到bar方法内部， 因为这里只是执行foo方法，如果像下面这样写，才会读到a = 3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function bar() &#123;</span><br><span class="line">  var a = 3;</span><br><span class="line"></span><br><span class="line">  function foo() &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="块级作用域的替代方案"><a href="#块级作用域的替代方案" class="headerlink" title="块级作用域的替代方案"></a>块级作用域的替代方案</h2><p>ES5之前块级作用域的解决方案catch或with</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try&#123; throw 2 &#125; catch(a)&#123;</span><br><span class="line">  console.log(a);  // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>let作用域或着let声明还可以这样用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let(a = 2) &#123;</span><br><span class="line">  console.log(a); // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a); // ReferenceError</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与隐式的劫持一个已经存在的作用域不同， let声明会显示的创建一个作用域并与其进行绑定。显示作用域不仅更突出，在代码重构时也表现更加健壮。<br>但是ES6语法不包含这个我们可以选择，合法的ES6语法，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 2;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以选择使用bable转换器 let-er这个转换器然后开启 这个设置项 。这样就可以直接使用了。</p>
<h2 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h2><p>为什么要使用this？ this提供了一种更优雅的方式来隐式的传递对象引用，因此可以将API设计的更加简洁并且易于复用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo(num) &#123;</span><br><span class="line">  console.log(&quot;foo:&quot; + num);</span><br><span class="line">  this.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = 0;</span><br><span class="line"></span><br><span class="line">var i;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  if(i &gt; 5) &#123;</span><br><span class="line">    foo(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//foo: 6</span><br><span class="line">//foo: 7</span><br><span class="line">//foo: 8</span><br><span class="line">//foo: 9</span><br><span class="line"></span><br><span class="line">console.log(foo.count); // 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的this并没有指向自身， foo被当作方法调用时，this代表的是函数的接收者。 这里非严格模式下指向的是全局对象，然而全局对象进行++运算结果是NaN，foo.count作为foo这个函数对象的一个属性从来没有改变过。</p>
<p>我们可以这样来改进x</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo(num) &#123;</span><br><span class="line">  console.log(&quot;foo:&quot; + num);</span><br><span class="line">  data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var data = &#123;</span><br><span class="line">  count: 0;</span><br><span class="line">&#125;</span><br><span class="line">var i;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  if(i &gt; 5) &#123;</span><br><span class="line">    foo(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//foo: 6</span><br><span class="line">//foo: 7</span><br><span class="line">//foo: 8</span><br><span class="line">//foo: 9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(foo.count); // 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样貌似解决了问题，但是忽略了真正的问题，无法理解this的含义和工作原理而是返回了舒适区。</p>
<p>另一种结局方案是使用foo标识符来替代this引用函数对象，但是同样回避了this的问题，并且完全依赖于变量foo的词法作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo(num) &#123;</span><br><span class="line">  console.log(&quot;foo:&quot; + num);</span><br><span class="line">  foo.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.count = 0;</span><br><span class="line"></span><br><span class="line">var i;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  if(i &gt; 5) &#123;</span><br><span class="line">    foo(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//foo: 6</span><br><span class="line">//foo: 7</span><br><span class="line">//foo: 8</span><br><span class="line">//foo: 9</span><br><span class="line"></span><br><span class="line">console.log(foo.count); // 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以强制使用this执行foo函数对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function foo(num) &#123;</span><br><span class="line">  console.log(&quot;foo:&quot; + num);</span><br><span class="line">  data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var data = &#123;</span><br><span class="line">  count: 0;</span><br><span class="line">&#125;</span><br><span class="line">var i;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  if(i &gt; 5) &#123;</span><br><span class="line">    foo.call(foo,i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//foo: 6</span><br><span class="line">//foo: 7</span><br><span class="line">//foo: 8</span><br><span class="line">//foo: 9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(foo.count); // 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>这是最常用的函数调用类型，独立函数调用。 这种情况this默认指向了全局对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo(); // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种方式加上了对于obj对象的引用，拥有了上下文，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上细纹对象。</p>
<p>对象属性的引用链只有上一层或者说最后一层在调用位置中起作用。举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  a: 42,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  obj2: obj2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1.obj2.foo(); // 42  最后一个obj2起作用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个最常见的this对象绑定问题就是隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而吧this绑定到全局对象或着<code>undefined</code>这取决于是否是严格模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var bar = obj.foo;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;;</span><br><span class="line"></span><br><span class="line">bar(); // oops, global</span><br></pre></td></tr></table></figure>
<p>还有一种，参数传递也是一种隐式赋值，因此我们穿日函数时也会被隐式赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFoo(fn) &#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var bar = obj.foo;</span><br><span class="line"></span><br><span class="line">var a = &quot;oops, global&quot;;</span><br><span class="line"></span><br><span class="line">doFoo(obj.foo); // oops, global</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同理如果向setTimeout中传递函数对象，同样会丢失this。</p>
<h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><p>显示绑定通常使用 <code>call</code>、<code>apply</code>、<code>bind</code>，这些方式来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>foo.call(…)， 我们可以调用foo时强制把它的this绑定到obj上。</p>
<p>可惜的是显示绑定仍然无法解决我们之前提出的丢失绑定的问题。但是显示绑定的一个变种可以帮我们解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = function() &#123;</span><br><span class="line">  foo.call(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 2</span><br><span class="line"></span><br><span class="line">setTimeout(bar, 100); // 2</span><br><span class="line"></span><br><span class="line">bar.call(window); // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>硬绑定的典型应用场景就是创建一个包裹函数，负责接收参数并返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo(something) &#123;</span><br><span class="line">  console.log(this.a, something);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = function() &#123;</span><br><span class="line">  return foo.apply(obj, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var b = bar(3); // 2, 3</span><br><span class="line"></span><br><span class="line">console.log(b);  // 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另一种使用方法是创建一个可以重复使用的辅助函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo(something) &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">  return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bind(fn, obj) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    fn.apply(obj, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = bind(foo, obj);</span><br><span class="line"></span><br><span class="line">var b = bar(3); // 2 3</span><br><span class="line"></span><br><span class="line">console.log(b); // 5</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于硬绑定是一种非常常用的模式，所以ES5提供了内置的方法<code>Function.ptototype.bind</code>，它的用法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function foo(something) &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">  return this.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = foo.bind(obj);</span><br><span class="line"></span><br><span class="line">var b = bar(3); // 2 3</span><br><span class="line"></span><br><span class="line">console.log(b); // 5</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>虽然JavaScript中也有new操作符，使用方法看起来跟那些面向类的语言意义，绝大多数开发者都认为JavaScript中的new的机制也跟那些语言一样，然而JavaScript中的new机制实际上跟面向类的语言完全不同。</p>
<ul>
<li>构造函数 首先JavaScript中的构造函数只是使用new操作符调用的函数，它们并不会属于某个类，也不会实例化一个类，实际上它们甚至不能说是一种特殊的函数类型，它们只是被new操作符调用的普通函数而已。 函数被使用new操作符调用成为构造函数调用，实际上不存在所谓的构造函数，只有对于函数的构造调用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  this.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new foo(2);</span><br><span class="line"></span><br><span class="line">console.log(bar.a); // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们创造了一个新的对象，并把它绑定到foo调用中的this上。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>显示绑定比隐式绑定优先级要高， new绑定比隐式绑定优先级要高， 但是new绑定会得到一个新的对象。</p>
<h2 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h2><ul>
<li><p>函数是否在new中调用， 如果是的话this绑定的是新创建的对象。</p>
</li>
<li><p>函数是否通过<code>call</code>，<code>apply</code>,或者硬绑定调用，如果是的话this是指定的对象</p>
</li>
<li><p>函数是否在某个上下文对象中（隐式绑定）如果是的话，this绑定的是上下文对象。</p>
</li>
<li><p>如果都不是的话，使用默认绑定。如果在严格模式下绑定到undefined， 否则绑定到全局对象。</p>
</li>
</ul>
<h2 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h2><p>如果你把null或undefined作为this绑定对象传入call，apply或者bind，这些值会在调用时被忽略，实际应用的是默认绑定规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">foo.call(null); // 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用null忽略this可能产生一些副作用，如果某个函数确实使用了this（比如第三方库的一个函数）， 那默认绑定规则会把this绑定到全局对象。这将导致不可预计的后果。<br>所以我们使用一个更安全的空对象<br>在JavaScript中创建一个空对象最简单的方法是Obejct.create(null), 它和{}很像，但是不会创建Object.ptototype，所以它比{}更空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">option + o</span><br><span class="line">var ø = Object.create(null);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h2><p>还有一个需要注意的情况你可能创建一个函数的间接引用，调用这个函数会应用默认绑定规则</p>
<p>间接引用最容易在赋值时发生</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  a: 3,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = &#123;</span><br><span class="line">  a: 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.foo(); // 3</span><br><span class="line"></span><br><span class="line">(p.foo = o.foo)(); // 2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>赋值表达式p.foo = o.foo的返回值是目标函数的引用，因此调用位置是foo() 而不是p.foo()或者o.foo();</p>
<h2 id="this词法"><a href="#this词法" class="headerlink" title="this词法"></a>this词法</h2><p><code>self = this</code>和箭头函数看起来都可以取代bind但本质上想取代的是this机制。如果你经常编写this风格的代码，但是绝大部份都会是用self = this,或者箭头函数，那么你或许应该</p>
<ul>
<li>只使用此法作用域并且完全抛弃错误this风格代码;</li>
<li>完全采用this风格，在必要时使用bind，避免使用self = this 和 箭头函数。</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在对象中，属性名永远都是字符串。使用非String作为属性名它首先会被转成一个字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myObject[true] = &quot;foo&quot;;</span><br><span class="line">myObject[3] = &quot;bar&quot;;</span><br><span class="line">myObject[myObject] = &quot;baz&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myObject[&quot;true&quot;] = &quot;foo&quot;;</span><br><span class="line">myObject[&quot;3&quot;] = &quot;bar&quot;;</span><br><span class="line">myObject[&quot;[object OBject]&quot;] = &quot;baz&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对象复制"><a href="#对象复制" class="headerlink" title="对象复制"></a>对象复制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">浅复制</span><br><span class="line">var newObj = Object.assign(&#123;&#125;, myObject);</span><br><span class="line"></span><br><span class="line">深复制</span><br><span class="line">对于JSON安全的对象来说有一种巧妙的复制方法</span><br><span class="line"></span><br><span class="line">var newObj = JSON.parse(JSON.stringify(someObj));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(myObject, &quot;a&quot;);</span><br><span class="line"></span><br><span class="line">// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line"></span><br><span class="line">如果configurable: false, 则不可以再配置，也不可以被删除</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h3><p>结合writable: false 和configurable: false就可以创建一个真正的常量属性(不可以重新定义，修改，删除)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProterty(myObject, &quot;FAVORITE_NUMBER&quot;, &#123;</span><br><span class="line">  value: 42,</span><br><span class="line">  writable: false,</span><br><span class="line">  configurable: false </span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h3><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(…)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.preventExtensions(myObject);</span><br><span class="line"></span><br><span class="line">myObject.b = 3;</span><br><span class="line"></span><br><span class="line">myObject.b; // undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在非严格模式下，创建属性b会静默失败，在严格模式下，将会抛出TyperError错误。</p>
<h3 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h3><p>Object.seal(…)会创建一个”密封”对象，这个方法实际会在一个现有对象上调用Object.preventExtensions并把所有现有属性标记为configurable: false.<br>所有密封后不能添加新属性，也不能重新配置和删除任何现有属性(虽然可以修改属性的值)</p>
<h3 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h3><p><code>Object.freeze(...)</code>，会创建一个冻结对象，这个方法是在现有对象调用了<code>Object.seal</code>并把所有数据访问属性标记为 writable: false, 这样就无法修改它们的值</p>
<h3 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">  get a() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(myObject, &quot;b&quot;, &#123;</span><br><span class="line">  get: function() &#123;</span><br><span class="line">    return this.a * 2;</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: true  </span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通常get和set是成对出现的，只定义一个的话通常会产生意料之外的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var myObject = &#123;</span><br><span class="line">  get a() &#123;</span><br><span class="line">    return this._a_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set a(val) &#123;</span><br><span class="line">    return this._a_ = val * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myObject.a = 2;</span><br><span class="line"></span><br><span class="line">myObject.a; // 4</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>前面说过 如果本身对象中有值为undefiend的属性obj.a, 去获取该值得到的结果跟去获取一个不存在的属性结果是一样的，比如obj.b， 那么如果判断一个属性在对象中是否存在呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var myObject = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(a in myObject); // true</span><br><span class="line">(b in myObject); // false</span><br><span class="line"></span><br><span class="line">myObject.hasOwnProperty(&quot;a&quot;); // true</span><br><span class="line">myObject.hasOwnProperty(&quot;b&quot;); // false</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>in操作符会检查属性是否存在对象及其[[prototype]]原型中，相比之下hasOwnProperty只会检查属性是否存在myObject对象中。</p>
<p>要注意的是in操作符检查的是容器内是否有某个值，实际上检查的是某个属性名是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 in [2, 4, 6]; // false</span><br><span class="line">这个数组包含的属性名其实是0 ，1，2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是否可通过for…in操作符来枚举可以通过定义属性是设定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(myObject, &quot;a&quot;, &#123;</span><br><span class="line">  enumerable: true, value: 2  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(myObject, &quot;b&quot;, &#123;</span><br><span class="line">  enumerable: false, value: 3</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myObject.b; //3</span><br><span class="line">&#123;&quot;b&quot; in myObject&#125;; //true</span><br><span class="line">myObject.hasOwnProperty(&quot;b&quot;); //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for(var k in myObject) &#123;</span><br><span class="line">  console.log(k, myObject[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &quot;a&quot; 2</span><br><span class="line"></span><br><span class="line">还可以通过另一种方式来区分属性是否可枚举</span><br><span class="line"></span><br><span class="line">propertyIsEnumerable 会检查属性是否存在于对象中(而不是在原型链中)并且满足enumerable: true</span><br><span class="line">Object.keys会返回一个数组，包含所有可枚举属性</span><br><span class="line">Object.getOwnPropertyNames 返回一个数组包含所有属性无论是否可枚举</span><br><span class="line"></span><br><span class="line">myObject.propertyIsEnumerable(&quot;a&quot;); // true</span><br><span class="line"></span><br><span class="line">myObject.propertyIsEnumerable(&quot;b&quot;); // false</span><br><span class="line"></span><br><span class="line">Object.keys(myObject); // [&quot;a&quot;]</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(myObject); // [&quot;a&quot;, &quot;b&quot;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Object.keys 和Object.getOwnPropertyNames 都不回查找原型链，只会查找对象直接包含的属性</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>我们通常会通过<code>for...in</code>来遍历一个对象，但是这样便利对象属性时的顺序是不确定的，在不同的JavaScript引擎中可能不一样，因此在不同的环境中需要保持一致性时，一定不要相信任何观察到顺序，它们是不可靠的<br>那么如何直接遍历值而不是数组下标呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var myArray = [1, 3, 5];</span><br><span class="line"></span><br><span class="line">for(var v of myArray) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为数组有内置的@iterator, 因此for…of可以直接应用到数组上。</p>
<p>我们可以使用内置的@@iterator来手动遍历数组， ES6中我们使用Symbol.iterator来获取对象的@@iterator内部属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myArray = [1, 3, 5];</span><br><span class="line"></span><br><span class="line">var it = myArray[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">it.next();  // &#123;value: 1, done: false&#125;</span><br><span class="line"></span><br><span class="line">it.next();  // &#123;value: 3, done: false&#125;</span><br><span class="line"></span><br><span class="line">it.next();  // &#123;value: 5, done: false&#125;</span><br><span class="line"></span><br><span class="line">it.next();  // &#123;value: undefined, done: undefined&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和数组不同普通的对象没有内置的@@iterator,所以无法自动完成for…of遍历，之所以这样做有许多非常复杂的原因， 简单来说，这样做是为了避免影响未来的对象类型.</p>
<p>当然我们可以给任何想遍历的对象定义@@iterator</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var myObject = &#123;</span><br><span class="line">  a: 2,</span><br><span class="line">  b: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(myObject, Symbol.iterator, &#123;</span><br><span class="line">  enumerable: false,</span><br><span class="line">  writable: false,</span><br><span class="line">  configurable: true,</span><br><span class="line">  value: function() &#123;</span><br><span class="line">    var o = this;</span><br><span class="line">    var idx = 0;</span><br><span class="line">    var ks = Object.keys(o);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      next: function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: o[ks[idx++]];</span><br><span class="line">          done: (idx &gt; ks.length)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">这样手动遍历</span><br><span class="line"></span><br><span class="line">var it = myObject[Symbol.iterator]();</span><br><span class="line">it.next(); // &#123;value:2, done: false&#125;</span><br><span class="line">it.next(); // &#123;value:3, done: false&#125;</span><br><span class="line">it.next(); // &#123;value: undefined, done: true&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for(var v of myObject) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="原型风格继承"><a href="#原型风格继承" class="headerlink" title="原型风格继承"></a>原型风格继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Foo(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = function() &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Bar(name, label) &#123;</span><br><span class="line">  Foo.call(this, name);</span><br><span class="line"></span><br><span class="line">  this.label = label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype = Object.create(Foo.prototype);</span><br><span class="line">// 这里还可以用这种写法，ES6 的 Object.setPrototypeOf  下面的写法更好一点， 当时上面的写法更容易理解</span><br><span class="line">Object.setPrototypeOf(Bar.prototype, Foo.prototype);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bar.prototype.myLabel = function() &#123;</span><br><span class="line">  return this.label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = new Bar(&quot;a&quot;, &quot;obj a&quot;);</span><br><span class="line"></span><br><span class="line">a.myName(); // &quot;a&quot;</span><br><span class="line"></span><br><span class="line">a.myLabel(); // &quot;obj a&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">该方法比较有用，Foo.prototype是否出现在a的[[prototype]]链中</span><br><span class="line">Foo.prototype.isPrototypeOf(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>基于委托实现与上面相同功能的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Foo = &#123;</span><br><span class="line">  init: function(who) &#123;</span><br><span class="line">    this.me = who;</span><br><span class="line">  &#125;,</span><br><span class="line">  identify: function() &#123;</span><br><span class="line">    return &quot;I am &quot; + this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar = Object.create(Foo);</span><br><span class="line"></span><br><span class="line">Bar.speak = function() &#123;</span><br><span class="line">  alert(&quot;Hello, &quot; + this.identify() + &quot; . &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var b1 = Object.create(Bar);</span><br><span class="line">b1.init(&quot;b1&quot;);</span><br><span class="line"></span><br><span class="line">var b2 = Object.create(Bar);</span><br><span class="line">b2.init(&quot;b2&quot;);</span><br><span class="line"></span><br><span class="line">b1.speak();</span><br><span class="line">b2.speak();</span><br></pre></td></tr></table></figure>

<p>通过比较发现， 对象关联风格的代码更加简洁，因为这种风格的代码只关注一件事， 对象之间的关联关系。</p>
<h2 id="更简洁的设计"><a href="#更简洁的设计" class="headerlink" title="更简洁的设计"></a>更简洁的设计</h2><p>一个关于登陆验证器的设计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Controller() &#123;</span><br><span class="line">  this.errors= [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Controller.prototype.showDialog = function(title, msg) &#123;</span><br><span class="line">  // 显示给用户的消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Controller.prototype.success = function(msg) &#123;</span><br><span class="line">  this.showDialog(&quot;success&quot;, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Controller.prototype.failure = function(err) &#123;</span><br><span class="line">  this.errors.push(err);</span><br><span class="line"></span><br><span class="line">  this.showDialog(&quot;Error&quot;, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function LoginController() &#123;</span><br><span class="line">  Controller.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginController.prototype = Object.create(Controller.prototype);</span><br><span class="line"></span><br><span class="line">LoginController.prototype.getUser = function() &#123;</span><br><span class="line">  return document.getElementById(&quot;login_username&quot;).value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginController.prototype.getPassword = function() &#123;</span><br><span class="line">  return document.getElementById(&quot;login_password&quot;).value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LoginController.prototype.validateEntry = function(user, pw) &#123;</span><br><span class="line">  user = user || this.getUser();</span><br><span class="line">  pw = pw || this.getPassword();</span><br><span class="line"></span><br><span class="line">  if(!(user &amp;&amp; pw)) &#123;</span><br><span class="line">    return this.failure(&quot;Please enter a username &amp; password&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else if(pw.length &lt; 5) &#123;</span><br><span class="line">    return this.failure(&quot;Password must be 5+ character!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LonginController.prototype.failure = function() &#123;</span><br><span class="line">  Controller.prototype.failure.call(this, &quot;Login invalid: &quot; + err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function AuthController(login) &#123;</span><br><span class="line">  Controller.call(this);</span><br><span class="line"></span><br><span class="line">  this.login = login;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AuthController.prototype = Object.create(Controller.prototype);</span><br><span class="line"></span><br><span class="line">AuthController.prototype.server = function(url, data) &#123;</span><br><span class="line">  return $.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    data: data</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AuthController.prototype.checkAuth = function() &#123;</span><br><span class="line">  var user = this.login.getUser();</span><br><span class="line">  var pw = this.login.getPassword();</span><br><span class="line"></span><br><span class="line">  if(this.login.validateEntry(user, pw)) &#123;</span><br><span class="line">    this.server(&quot;/check-auth&quot;, &#123;</span><br><span class="line">      user: user,</span><br><span class="line">      pw: pw</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(this.success.bind(this));</span><br><span class="line">    .fail(this.failure.bind(this));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AuthController.prototype.success = function() &#123;</span><br><span class="line">  Controller.prototype.success.call(this, &quot;Authenticated;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AuthController.prototype.failure = function(err) &#123;</span><br><span class="line">  Controller.prototype.failure.call(this, &quot;Auth failed: &quot; + err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var auth = new AuthController(new LoginController());</span><br><span class="line"></span><br><span class="line">auth.checkAuth();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反类，我们可以使用对象关联风格的行为委托来实现更简单的设计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var LoginController = &#123;</span><br><span class="line">  errors: [],</span><br><span class="line">  getUser: function() &#123;</span><br><span class="line">    return document.getElementById(&quot;login_username&quot;).value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getPassword: function() &#123;</span><br><span class="line">    return document.getElementById(&quot;login_password&quot;).value;</span><br><span class="line">  &#125;,</span><br><span class="line">  validateEntry: function(user, pw) &#123;</span><br><span class="line">    user = user || this.getUser();</span><br><span class="line">    pw = pw || this.getPassword();</span><br><span class="line"></span><br><span class="line">    if(!(user &amp;&amp; pw)) &#123;</span><br><span class="line">      return this.failure(&quot;Please enter a username &amp; password&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pw.length &lt; 5) &#123;</span><br><span class="line">      return this.failure(&quot;Password must be 5+ character!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">  &#125;,</span><br><span class="line">  showDialog: function() &#123;</span><br><span class="line">    // 给用户显示的消息</span><br><span class="line">  &#125;,</span><br><span class="line">  failure: function() &#123;</span><br><span class="line">    this.errors.push(err);</span><br><span class="line">    this.showDialog(&quot;Error&quot;, &quot;Login invalid &quot; + err);</span><br><span class="line">  &#125;,</span><br><span class="line">  success: function(msg) &#123;</span><br><span class="line">    this.showDialog(&quot;success&quot;, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var AuthController = Object.create(LoginController);</span><br><span class="line"></span><br><span class="line">AuthController.errors = [];</span><br><span class="line"></span><br><span class="line">AuthController.checkAuth = function() &#123;</span><br><span class="line">  var user = this.getUser();</span><br><span class="line">  var pw = this.getPassword();</span><br><span class="line"></span><br><span class="line">  if(this.validateEntry(user, pw)) &#123;</span><br><span class="line">    this.server(&quot;/check-auth&quot;, &#123;</span><br><span class="line">      user: user,</span><br><span class="line">      pw: pw  </span><br><span class="line">    &#125;)</span><br><span class="line">    .then(this.accepted.bind(this))</span><br><span class="line">    .fail(this.rejected.bind(this));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AuthController.server = function(url, data) &#123;</span><br><span class="line">  return $.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    data: data  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AuthController.accepted = function() &#123;</span><br><span class="line">  this.showDialog(&quot;Success&quot;, &quot;Authenticated!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AuthController.rejected = function(err) &#123;</span><br><span class="line">  this.failure(&quot;Auth Failed: &quot; + err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AuthController.checkAuth();</span><br></pre></td></tr></table></figure>
<p>这种模式我们只需要两个实体LoginController 和 AuthController<br>总结： 我们用一种极其简单的设计实现了同样的功能， 这既是对象关联风格代码和行为委托设计模式的力量</p>
<h2 id="反词法"><a href="#反词法" class="headerlink" title="反词法"></a>反词法</h2><p>ES6简洁与法有一个非常小但重要的缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var Foo = &#123;</span><br><span class="line">  bar() &#123;/**/&#125;,</span><br><span class="line">  baz: function baz() &#123;/**/&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">去掉语法糖</span><br><span class="line"></span><br><span class="line">var Foo = &#123;</span><br><span class="line">  bar: function() &#123;/**/&#125;</span><br><span class="line">  baz: function baz() &#123;/**/&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于函数对象本身没有标识符， 所以bar()的缩写形式实际上会变成一个匿名函数表达式并赋值给bar属性。相比之下 具名函数表达式会额外的给.baz属性附加一个词法名称标识符baz。</p>
<p>匿名函数没有name标识符会导致</p>
<ul>
<li>调用栈更难追踪</li>
<li>自我引用（递归， 事件绑定和解除绑定）更难</li>
<li>代码稍微难理解</li>
</ul>
<p>这里只有第二个缺点无法避免，因此使用简洁语法一定要小心这一点。 如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数，不要使用简洁语法。</p>
<blockquote>
<p>再说一次，我们认为JavaScript种的对象关联比类风格代码更为简洁(而且功能相同)</p>
</blockquote>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>toshiba</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://sdongzhi.com/2018/10/08/read-book-you-known-up-one/" title="你不知道的JavaScript上卷">https://sdongzhi.com/2018/10/08/read-book-you-known-up-one/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2018/10/18/read-book-you-known-middle-one/" rel="prev" title="你不知道的JavaScript中卷(一)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">你不知道的JavaScript中卷(一)</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2018/09/28/read-book-effective-nine/" rel="next" title="Effective JavaScript (九)"><span class="post-nav-text">Effective JavaScript (九)</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2017 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 多弗朗明哥</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script defer src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-tag-common@latest/js/index.js"></script><!-- hexo injector body_end end --></body></html>